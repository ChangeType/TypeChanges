<!-- #######  YAY, I AM THE SOURCE EDITOR! #########-->

<!DOCTYPE html>
<html lang="en">
<head>

    <!-- Basic Page Needs
    ================================================== -->
    <meta charset="utf-8">
    <title>io.netty.util.concurrent.Future to org.redisson.api.RFuture</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Mobile Specific Metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Favicons
    ================================================== -->
    <link rel="icon" href="img/favicon/favicon-32x32.png" type="image/x-icon"/>
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/favicon/favicon-144x144.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/favicon/favicon-72x72.png">
    <link rel="apple-touch-icon-precomposed" href="img/favicon/favicon-54x54.png">

    <!-- CSS
    ================================================== -->

    <!-- Bootstrap -->
    <link rel="stylesheet" href="../../css/bootstrap.min.css">
    <!-- Template styles-->
    <link rel="stylesheet" href="../../css/style.css">
    <!-- Responsive styles-->
    <link rel="stylesheet" href="../../css/responsive.css">
    <!-- FontAwesome -->
    <link rel="stylesheet" href="../../css/font-awesome.min.css">
    <!-- Animation -->
    <link rel="stylesheet" href="../../css/animate.css">
    <!-- Prettyphoto -->
    <link rel="stylesheet" href="../../css/prettyPhoto.css">
    <!-- Owl Carousel -->
    <link rel="stylesheet" href="../../css/owl.carousel.css">
    <link rel="stylesheet" href="../../css/owl.theme.css">
    <!-- Flexslider -->
    <link rel="stylesheet" href="../../css/flexslider.css">
    <!-- Flexslider -->
    <link rel="stylesheet" href="../../css/cd-hero.css">
    <!-- Style Swicther -->
    <link id="style-switch" href="../../css/presets/preset3.css" media="screen" rel="stylesheet" type="text/css">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements. All other JS at the end of file. -->
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]-->

</head>

<body>
<div class="body-inner">
    <header id="header" class="navbar-fixed-top header" role="banner">
        <div class="container">
            <div class="row">
                <div class="col-md-12 heading">
                    <!-- Logo start -->
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse"
                                data-target=".navbar-collapse">
                            <span class="sr-only">Toggle navigation</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                    </div><!--/ Logo end -->
                    <nav class="collapse navbar-collapse clearfix" role="navigation">
                        <ul class="nav navbar-nav navbar-right">
                            <li><a href="../../index.html"><p class="text-danger">Home</p></a></li>
<!--                            <li><a href=..\redisson><p class="text-danger">Examples</p></a></li>-->
                        </ul>
                    </nav><!--/ Navigation end -->
                </div><!--/ Row end -->
            </div>
        </div><!--/ Container end -->
    </header><!--/ Header end -->


    <section id="main-container">
        <div class="container">

            <!-- Company Profile -->
            <div class="row">
<!--                <div class="col-md-12 heading">-->
                    <!--<span class="title-icon classic pull-left"><i class="fa fa-suitcase"></i></span>-->
                    <h2 class="title classic">io.netty.util.concurrent.Future to org.redisson.api.RFuture</h2>
                    <!--<h2 class="title classic">URL: </h2>-->
<!--                </div>-->
            </div>
        </div>
        <div class="container">
            <div class="row">
                <h3>No. of Instances - 1123</h3>
                <h3>No. of Commits - 3</h3>
                <h3>No. of Projects - {'redisson'}</h3>
                <h3>Hierarchy/Composition: T_SUPER_R</h3>
                <h3>Primitive Info: -</h3>
                <h3>NameSpace: External -> Internal</h3>
                <h3>Mapping:</h3>
            </div>
            <div class="col-md-12 heading">
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-md-12 heading">
                        <ol>
                            
                            <li><a href="#" onclick="toggle_visibility('CascadingTypeDifferent');"><i class="fa fa-plus"
                                                                                                aria-hidden="true">
                                CascadingTypeDifferent</i></a></li>
                            <ul id="CascadingTypeDifferent" , style="display: none;">
                                
                                <li><a href="https://github.com/redisson/redisson/commit/cbe9ae6c0f72bdc6bdbe79440b1699c26a04ff5d?diff=split#diff-3afbe7033ddf014aa4890b207ac18adaL137">Promise&lt;V&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/cbe9ae6c0f72bdc6bdbe79440b1699c26a04ff5d?diff=split#diff-3afbe7033ddf014aa4890b207ac18adaR139">RPromise&lt;V&gt;</a>
                                </li>
                                
                            </ul>
                            
                            <li><a href="#" onclick="toggle_visibility('CascadingType');"><i class="fa fa-plus"
                                                                                                aria-hidden="true">
                                CascadingType</i></a></li>
                            <ul id="CascadingType" , style="display: none;">
                                
                                <li><a href="https://github.com/redisson/redisson/commit/cbe9ae6c0f72bdc6bdbe79440b1699c26a04ff5d?diff=split#diff-e9723e04730354945bb694ba7f83b1b5L181">Future&lt;Long&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/cbe9ae6c0f72bdc6bdbe79440b1699c26a04ff5d?diff=split#diff-e9723e04730354945bb694ba7f83b1b5R183">RFuture&lt;Long&gt;</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L481">Future&lt;RedissonLockEntry&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R480">RFuture&lt;RedissonLockEntry&gt;</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eL517">Future&lt;Void&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eR518">RFuture&lt;Void&gt;</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-927431847749cd5f81c3c3be64de411eL107">Future&lt;RedissonLockEntry&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-927431847749cd5f81c3c3be64de411eR106">RFuture&lt;RedissonLockEntry&gt;</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35L479">Future&lt;RemoteServiceAck&gt;</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35R479">RFuture&lt;RemoteServiceAck&gt;</a>
                                </li>
                                
                            </ul>
                            
                            <li><a href="#" onclick="toggle_visibility('AddRemoveMthdInvc');"><i class="fa fa-plus"
                                                                                                aria-hidden="true">
                                AddRemoveMthdInvc</i></a></li>
                            <ul id="AddRemoveMthdInvc" , style="display: none;">
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-cba98c5add595f1872f996da132a5512L254">checkConnectionFuture(entry,source,mainPromise,attemptPromise,details,connFuture)</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-cba98c5add595f1872f996da132a5512R254">checkConnectionFuture(entry,source,mainPromise,attemptPromise,details,connectionFuture)</a>
                                </li>
                                
                            </ul>
                            
                            <li><a href="#" onclick="toggle_visibility('UpdateAnonymCls');"><i class="fa fa-plus"
                                                                                                aria-hidden="true">
                                UpdateAnonymCls</i></a></li>
                            <ul id="UpdateAnonymCls" , style="display: none;">
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35L266">{
  @Override public void operationComplete(  Future&lt;RemoteServiceAck&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.tryFailure(future.cause());
      return;
    }
    RemoteServiceAck ack=future.getNow();
    if (ack == null) {
      Future&lt;RemoteServiceAck&gt; ackFutureAttempt=tryPollAckAgainAsync(optionsCopy,responseQueue,ackName);
      ackFutureAttempt.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
        @Override public void operationComplete(        Future&lt;RemoteServiceAck&gt; future) throws Exception {
          if (!future.isSuccess()) {
            result.tryFailure(future.cause());
            return;
          }
          if (future.getNow() == null) {
            Exception ex=new RemoteServiceAckTimeoutException(&quot;No ACK response after &quot; + optionsCopy.getAckTimeoutInMillis() + &quot;ms for request: &quot;+ request);
            result.tryFailure(ex);
            return;
          }
          awaitResultAsync(optionsCopy,result,request,responseName,ackName);
        }
      }
);
    }
 else {
      awaitResultAsync(optionsCopy,result,request,responseName);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35R266">{
  @Override public void operationComplete(  Future&lt;RemoteServiceAck&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.tryFailure(future.cause());
      return;
    }
    RemoteServiceAck ack=future.getNow();
    if (ack == null) {
      RFuture&lt;RemoteServiceAck&gt; ackFutureAttempt=tryPollAckAgainAsync(optionsCopy,responseQueue,ackName);
      ackFutureAttempt.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
        @Override public void operationComplete(        Future&lt;RemoteServiceAck&gt; future) throws Exception {
          if (!future.isSuccess()) {
            result.tryFailure(future.cause());
            return;
          }
          if (future.getNow() == null) {
            Exception ex=new RemoteServiceAckTimeoutException(&quot;No ACK response after &quot; + optionsCopy.getAckTimeoutInMillis() + &quot;ms for request: &quot;+ request);
            result.tryFailure(ex);
            return;
          }
          awaitResultAsync(optionsCopy,result,request,responseName,ackName);
        }
      }
);
    }
 else {
      awaitResultAsync(optionsCopy,result,request,responseName);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-e955ff8205bf89cc7e686b012ae23f22L111">{
  @Override public void operationComplete(  Future&lt;RemoteServiceRequest&gt; future) throws Exception {
    if (!future.isSuccess()) {
      if (future.cause() instanceof RedissonShutdownException) {
        return;
      }
      subscribe(remoteInterface,requestQueue,executor);
      return;
    }
    final RemoteServiceRequest request=future.getNow();
    if (request.getOptions().isAckExpected() &amp;&amp; System.currentTimeMillis() - request.getDate() &gt; request.getOptions().getAckTimeoutInMillis()) {
      log.debug(&quot;request: {} has been skipped due to ackTimeout&quot;);
      subscribe(remoteInterface,requestQueue,executor);
      return;
    }
    final String responseName=getResponseQueueName(remoteInterface,request.getRequestId());
    if (request.getOptions().isAckExpected()) {
      String ackName=getAckName(remoteInterface,request.getRequestId());
      Future&lt;Boolean&gt; ackClientsFuture=commandExecutor.evalWriteAsync(responseName,LongCodec.INSTANCE,RedisCommands.EVAL_BOOLEAN,&quot;if redis.call(&#x27;setnx&#x27;, KEYS[1], 1) == 1 then &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]);&quot; + &quot;redis.call(&#x27;rpush&#x27;, KEYS[2], ARGV[1]);&quot;+ &quot;redis.call(&#x27;pexpire&#x27;, KEYS[2], ARGV[2]);&quot;+ &quot;return 1;&quot;+ &quot;end;&quot;+ &quot;return 0;&quot;,Arrays.&lt;Object&gt;asList(ackName,responseName),encode(new RemoteServiceAck()),request.getOptions().getAckTimeoutInMillis());
      ackClientsFuture.addListener(new FutureListener&lt;Boolean&gt;(){
        @Override public void operationComplete(        Future&lt;Boolean&gt; future) throws Exception {
          if (!future.isSuccess()) {
            log.error(&quot;Can&#x27;t send ack for request: &quot; + request,future.cause());
            if (future.cause() instanceof RedissonShutdownException) {
              return;
            }
            subscribe(remoteInterface,requestQueue,executor);
            return;
          }
          if (!future.getNow()) {
            subscribe(remoteInterface,requestQueue,executor);
            return;
          }
          executeMethod(remoteInterface,requestQueue,executor,request);
        }
      }
);
    }
 else {
      executeMethod(remoteInterface,requestQueue,executor,request);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-e955ff8205bf89cc7e686b012ae23f22R112">{
  @Override public void operationComplete(  Future&lt;RemoteServiceRequest&gt; future) throws Exception {
    if (!future.isSuccess()) {
      if (future.cause() instanceof RedissonShutdownException) {
        return;
      }
      subscribe(remoteInterface,requestQueue,executor);
      return;
    }
    final RemoteServiceRequest request=future.getNow();
    if (request.getOptions().isAckExpected() &amp;&amp; System.currentTimeMillis() - request.getDate() &gt; request.getOptions().getAckTimeoutInMillis()) {
      log.debug(&quot;request: {} has been skipped due to ackTimeout&quot;);
      subscribe(remoteInterface,requestQueue,executor);
      return;
    }
    final String responseName=getResponseQueueName(remoteInterface,request.getRequestId());
    if (request.getOptions().isAckExpected()) {
      String ackName=getAckName(remoteInterface,request.getRequestId());
      RFuture&lt;Boolean&gt; ackClientsFuture=commandExecutor.evalWriteAsync(responseName,LongCodec.INSTANCE,RedisCommands.EVAL_BOOLEAN,&quot;if redis.call(&#x27;setnx&#x27;, KEYS[1], 1) == 1 then &quot; + &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]);&quot; + &quot;redis.call(&#x27;rpush&#x27;, KEYS[2], ARGV[1]);&quot;+ &quot;redis.call(&#x27;pexpire&#x27;, KEYS[2], ARGV[2]);&quot;+ &quot;return 1;&quot;+ &quot;end;&quot;+ &quot;return 0;&quot;,Arrays.&lt;Object&gt;asList(ackName,responseName),encode(new RemoteServiceAck()),request.getOptions().getAckTimeoutInMillis());
      ackClientsFuture.addListener(new FutureListener&lt;Boolean&gt;(){
        @Override public void operationComplete(        Future&lt;Boolean&gt; future) throws Exception {
          if (!future.isSuccess()) {
            log.error(&quot;Can&#x27;t send ack for request: &quot; + request,future.cause());
            if (future.cause() instanceof RedissonShutdownException) {
              return;
            }
            subscribe(remoteInterface,requestQueue,executor);
            return;
          }
          if (!future.getNow()) {
            subscribe(remoteInterface,requestQueue,executor);
            return;
          }
          executeMethod(remoteInterface,requestQueue,executor,request);
        }
      }
);
    }
 else {
      executeMethod(remoteInterface,requestQueue,executor,request);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-6b730ea8c46f2553768f16267da5df5aL305">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (entry.getFreezeReason() != FreezeReason.RECONNECT || !entry.isFreezed()) {
      return;
    }
    if (!future.isSuccess()) {
      scheduleCheck(entry);
      return;
    }
    final RedisConnection c=future.getNow();
    if (!c.isActive()) {
      c.closeAsync();
      scheduleCheck(entry);
      return;
    }
    final FutureListener&lt;String&gt; pingListener=new FutureListener&lt;String&gt;(){
      @Override public void operationComplete(      Future&lt;String&gt; future) throws Exception {
        try {
          if (entry.getFreezeReason() != FreezeReason.RECONNECT || !entry.isFreezed()) {
            return;
          }
          if (future.isSuccess() &amp;&amp; &quot;PONG&quot;.equals(future.getNow())) {
            entry.resetFailedAttempts();
            Promise&lt;Void&gt; promise=connectionManager.newPromise();
            promise.addListener(new FutureListener&lt;Void&gt;(){
              @Override public void operationComplete(              Future&lt;Void&gt; future) throws Exception {
                if (entry.getNodeType() == NodeType.SLAVE) {
                  masterSlaveEntry.slaveUp(entry.getClient().getAddr().getHostName(),entry.getClient().getAddr().getPort(),FreezeReason.RECONNECT);
                  log.info(&quot;slave {} successfully reconnected&quot;,entry.getClient().getAddr());
                }
 else {
synchronized (entry) {
                    if (entry.getFreezeReason() == FreezeReason.RECONNECT) {
                      entry.setFreezed(false);
                      entry.setFreezeReason(null);
                      log.info(&quot;host {} successfully reconnected&quot;,entry.getClient().getAddr());
                    }
                  }
                }
              }
            }
);
            initConnections(entry,promise,false);
          }
 else {
            scheduleCheck(entry);
          }
        }
  finally {
          c.closeAsync();
        }
      }
    }
;
    if (entry.getConfig().getPassword() != null) {
      Future&lt;Void&gt; temp=c.async(RedisCommands.AUTH,config.getPassword());
      FutureListener&lt;Void&gt; listener=new FutureListener&lt;Void&gt;(){
        @Override public void operationComplete(        Future&lt;Void&gt; future) throws Exception {
          ping(c,pingListener);
        }
      }
;
      temp.addListener(listener);
    }
 else {
      ping(c,pingListener);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-6b730ea8c46f2553768f16267da5df5aR306">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (entry.getFreezeReason() != FreezeReason.RECONNECT || !entry.isFreezed()) {
      return;
    }
    if (!future.isSuccess()) {
      scheduleCheck(entry);
      return;
    }
    final RedisConnection c=future.getNow();
    if (!c.isActive()) {
      c.closeAsync();
      scheduleCheck(entry);
      return;
    }
    final FutureListener&lt;String&gt; pingListener=new FutureListener&lt;String&gt;(){
      @Override public void operationComplete(      Future&lt;String&gt; future) throws Exception {
        try {
          if (entry.getFreezeReason() != FreezeReason.RECONNECT || !entry.isFreezed()) {
            return;
          }
          if (future.isSuccess() &amp;&amp; &quot;PONG&quot;.equals(future.getNow())) {
            entry.resetFailedAttempts();
            RPromise&lt;Void&gt; promise=connectionManager.newPromise();
            promise.addListener(new FutureListener&lt;Void&gt;(){
              @Override public void operationComplete(              Future&lt;Void&gt; future) throws Exception {
                if (entry.getNodeType() == NodeType.SLAVE) {
                  masterSlaveEntry.slaveUp(entry.getClient().getAddr().getHostName(),entry.getClient().getAddr().getPort(),FreezeReason.RECONNECT);
                  log.info(&quot;slave {} successfully reconnected&quot;,entry.getClient().getAddr());
                }
 else {
synchronized (entry) {
                    if (entry.getFreezeReason() == FreezeReason.RECONNECT) {
                      entry.setFreezed(false);
                      entry.setFreezeReason(null);
                      log.info(&quot;host {} successfully reconnected&quot;,entry.getClient().getAddr());
                    }
                  }
                }
              }
            }
);
            initConnections(entry,promise,false);
          }
 else {
            scheduleCheck(entry);
          }
        }
  finally {
          c.closeAsync();
        }
      }
    }
;
    if (entry.getConfig().getPassword() != null) {
      RFuture&lt;Void&gt; temp=c.async(RedisCommands.AUTH,config.getPassword());
      FutureListener&lt;Void&gt; listener=new FutureListener&lt;Void&gt;(){
        @Override public void operationComplete(        Future&lt;Void&gt; future) throws Exception {
          ping(c,pingListener);
        }
      }
;
      temp.addListener(listener);
    }
 else {
      ping(c,pingListener);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-927431847749cd5f81c3c3be64de411eL321">{
  @Override public void operationComplete(  Future&lt;Boolean&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.setFailure(future.cause());
      return;
    }
    if (future.getNow()) {
      result.setSuccess(true);
      return;
    }
    final long current=System.currentTimeMillis();
    final AtomicReference&lt;Timeout&gt; futureRef=new AtomicReference&lt;Timeout&gt;();
    final Future&lt;RedissonLockEntry&gt; subscribeFuture=subscribe();
    subscribeFuture.addListener(new FutureListener&lt;RedissonLockEntry&gt;(){
      @Override public void operationComplete(      Future&lt;RedissonLockEntry&gt; future) throws Exception {
        if (!future.isSuccess()) {
          result.setFailure(future.cause());
          return;
        }
        if (futureRef.get() != null) {
          futureRef.get().cancel();
        }
        long elapsed=System.currentTimeMillis() - current;
        time.addAndGet(-elapsed);
        if (time.get() &lt; 0) {
          unsubscribe(subscribeFuture);
          result.trySuccess(false);
          return;
        }
        tryAcquireAsync(time,permits,subscribeFuture,result);
      }
    }
);
    if (!subscribeFuture.isDone()) {
      Timeout scheduledFuture=commandExecutor.getConnectionManager().newTimeout(new TimerTask(){
        @Override public void run(        Timeout timeout) throws Exception {
          if (!subscribeFuture.isDone()) {
            result.trySuccess(false);
          }
        }
      }
,time.get(),TimeUnit.MILLISECONDS);
      futureRef.set(scheduledFuture);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-927431847749cd5f81c3c3be64de411eR320">{
  @Override public void operationComplete(  Future&lt;Boolean&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.setFailure(future.cause());
      return;
    }
    if (future.getNow()) {
      result.setSuccess(true);
      return;
    }
    final long current=System.currentTimeMillis();
    final AtomicReference&lt;Timeout&gt; futureRef=new AtomicReference&lt;Timeout&gt;();
    final RFuture&lt;RedissonLockEntry&gt; subscribeFuture=subscribe();
    subscribeFuture.addListener(new FutureListener&lt;RedissonLockEntry&gt;(){
      @Override public void operationComplete(      Future&lt;RedissonLockEntry&gt; future) throws Exception {
        if (!future.isSuccess()) {
          result.setFailure(future.cause());
          return;
        }
        if (futureRef.get() != null) {
          futureRef.get().cancel();
        }
        long elapsed=System.currentTimeMillis() - current;
        time.addAndGet(-elapsed);
        if (time.get() &lt; 0) {
          unsubscribe(subscribeFuture);
          result.trySuccess(false);
          return;
        }
        tryAcquireAsync(time,permits,subscribeFuture,result);
      }
    }
);
    if (!subscribeFuture.isDone()) {
      Timeout scheduledFuture=commandExecutor.getConnectionManager().newTimeout(new TimerTask(){
        @Override public void run(        Timeout timeout) throws Exception {
          if (!subscribeFuture.isDone()) {
            result.trySuccess(false);
          }
        }
      }
,time.get(),TimeUnit.MILLISECONDS);
      futureRef.set(scheduledFuture);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eL217">{
  @Override public void operationComplete(  Future&lt;Map&lt;String,String&gt;&gt; future) throws Exception {
    if (!future.isSuccess()) {
      log.error(&quot;Can&#x27;t execute CLUSTER_INFO for &quot; + connection.getRedisClient().getAddr(),future.cause());
      result.setFailure(future.cause());
      return;
    }
    Map&lt;String,String&gt; params=future.getNow();
    if (&quot;fail&quot;.equals(params.get(&quot;cluster_state&quot;))) {
      RedisException e=new RedisException(&quot;Failed to add master: &quot; + partition.getMasterAddress() + &quot; for slot ranges: &quot;+ partition.getSlotRanges()+ &quot;. Reason - cluster_state:fail&quot;);
      log.error(&quot;cluster_state:fail for &quot; + connection.getRedisClient().getAddr());
      result.setFailure(e);
      return;
    }
    MasterSlaveServersConfig config=create(cfg);
    config.setMasterAddress(partition.getMasterAddress());
    final MasterSlaveEntry e;
    List&lt;Future&lt;Void&gt;&gt; futures=new ArrayList&lt;Future&lt;Void&gt;&gt;();
    if (config.getReadMode() == ReadMode.MASTER) {
      e=new SingleEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
    }
 else {
      config.setSlaveAddresses(partition.getSlaveAddresses());
      e=new MasterSlaveEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
      List&lt;Future&lt;Void&gt;&gt; fs=e.initSlaveBalancer(partition.getFailedSlaveAddresses());
      futures.addAll(fs);
      if (!partition.getSlaveAddresses().isEmpty()) {
        log.info(&quot;slaves: {} added for slot ranges: {}&quot;,partition.getSlaveAddresses(),partition.getSlotRanges());
        if (!partition.getFailedSlaveAddresses().isEmpty()) {
          log.warn(&quot;slaves: {} is down for slot ranges: {}&quot;,partition.getFailedSlaveAddresses(),partition.getSlotRanges());
        }
      }
    }
    Future&lt;Void&gt; f=e.setupMasterEntry(config.getMasterAddress().getHost(),config.getMasterAddress().getPort());
    final Promise&lt;Void&gt; initFuture=newPromise();
    futures.add(initFuture);
    f.addListener(new FutureListener&lt;Void&gt;(){
      @Override public void operationComplete(      Future&lt;Void&gt; future) throws Exception {
        if (!future.isSuccess()) {
          log.error(&quot;Can&#x27;t add master: {} for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
          initFuture.setFailure(future.cause());
          return;
        }
        for (        Integer slot : partition.getSlots()) {
          addEntry(slot,e);
          lastPartitions.put(slot,partition);
        }
        log.info(&quot;master: {} added for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
        initFuture.setSuccess(null);
      }
    }
);
    result.setSuccess(futures);
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eR218">{
  @Override public void operationComplete(  Future&lt;Map&lt;String,String&gt;&gt; future) throws Exception {
    if (!future.isSuccess()) {
      log.error(&quot;Can&#x27;t execute CLUSTER_INFO for &quot; + connection.getRedisClient().getAddr(),future.cause());
      result.setFailure(future.cause());
      return;
    }
    Map&lt;String,String&gt; params=future.getNow();
    if (&quot;fail&quot;.equals(params.get(&quot;cluster_state&quot;))) {
      RedisException e=new RedisException(&quot;Failed to add master: &quot; + partition.getMasterAddress() + &quot; for slot ranges: &quot;+ partition.getSlotRanges()+ &quot;. Reason - cluster_state:fail&quot;);
      log.error(&quot;cluster_state:fail for &quot; + connection.getRedisClient().getAddr());
      result.setFailure(e);
      return;
    }
    MasterSlaveServersConfig config=create(cfg);
    config.setMasterAddress(partition.getMasterAddress());
    final MasterSlaveEntry e;
    List&lt;RFuture&lt;Void&gt;&gt; futures=new ArrayList&lt;RFuture&lt;Void&gt;&gt;();
    if (config.getReadMode() == ReadMode.MASTER) {
      e=new SingleEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
    }
 else {
      config.setSlaveAddresses(partition.getSlaveAddresses());
      e=new MasterSlaveEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
      List&lt;RFuture&lt;Void&gt;&gt; fs=e.initSlaveBalancer(partition.getFailedSlaveAddresses());
      futures.addAll(fs);
      if (!partition.getSlaveAddresses().isEmpty()) {
        log.info(&quot;slaves: {} added for slot ranges: {}&quot;,partition.getSlaveAddresses(),partition.getSlotRanges());
        if (!partition.getFailedSlaveAddresses().isEmpty()) {
          log.warn(&quot;slaves: {} is down for slot ranges: {}&quot;,partition.getFailedSlaveAddresses(),partition.getSlotRanges());
        }
      }
    }
    RFuture&lt;Void&gt; f=e.setupMasterEntry(config.getMasterAddress().getHost(),config.getMasterAddress().getPort());
    final RPromise&lt;Void&gt; initFuture=newPromise();
    futures.add(initFuture);
    f.addListener(new FutureListener&lt;Void&gt;(){
      @Override public void operationComplete(      Future&lt;Void&gt; future) throws Exception {
        if (!future.isSuccess()) {
          log.error(&quot;Can&#x27;t add master: {} for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
          initFuture.setFailure(future.cause());
          return;
        }
        for (        Integer slot : partition.getSlots()) {
          addEntry(slot,e);
          lastPartitions.put(slot,partition);
        }
        log.info(&quot;master: {} added for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
        initFuture.setSuccess(null);
      }
    }
);
    result.setSuccess(futures);
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L600">{
  @Override public void operationComplete(  Future&lt;Long&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.setFailure(future.cause());
      return;
    }
    Long ttl=future.getNow();
    if (ttl == null) {
      result.setSuccess(true);
      return;
    }
    final long current=System.currentTimeMillis();
    final AtomicReference&lt;Timeout&gt; futureRef=new AtomicReference&lt;Timeout&gt;();
    final Future&lt;RedissonLockEntry&gt; subscribeFuture=subscribe(currentThreadId);
    subscribeFuture.addListener(new FutureListener&lt;RedissonLockEntry&gt;(){
      @Override public void operationComplete(      Future&lt;RedissonLockEntry&gt; future) throws Exception {
        if (!future.isSuccess()) {
          result.tryFailure(future.cause());
          return;
        }
        if (futureRef.get() != null) {
          futureRef.get().cancel();
        }
        long elapsed=System.currentTimeMillis() - current;
        time.addAndGet(-elapsed);
        if (time.get() &lt; 0) {
          unsubscribe(subscribeFuture,currentThreadId);
          result.trySuccess(false);
          return;
        }
        tryLockAsync(time,leaseTime,unit,subscribeFuture,result,currentThreadId);
      }
    }
);
    if (!subscribeFuture.isDone()) {
      Timeout scheduledFuture=commandExecutor.getConnectionManager().newTimeout(new TimerTask(){
        @Override public void run(        Timeout timeout) throws Exception {
          if (!subscribeFuture.isDone()) {
            subscribeFuture.cancel(false);
            result.trySuccess(false);
          }
        }
      }
,time.get(),TimeUnit.MILLISECONDS);
      futureRef.set(scheduledFuture);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R599">{
  @Override public void operationComplete(  Future&lt;Long&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.setFailure(future.cause());
      return;
    }
    Long ttl=future.getNow();
    if (ttl == null) {
      result.setSuccess(true);
      return;
    }
    final long current=System.currentTimeMillis();
    final AtomicReference&lt;Timeout&gt; futureRef=new AtomicReference&lt;Timeout&gt;();
    final RFuture&lt;RedissonLockEntry&gt; subscribeFuture=subscribe(currentThreadId);
    subscribeFuture.addListener(new FutureListener&lt;RedissonLockEntry&gt;(){
      @Override public void operationComplete(      Future&lt;RedissonLockEntry&gt; future) throws Exception {
        if (!future.isSuccess()) {
          result.tryFailure(future.cause());
          return;
        }
        if (futureRef.get() != null) {
          futureRef.get().cancel();
        }
        long elapsed=System.currentTimeMillis() - current;
        time.addAndGet(-elapsed);
        if (time.get() &lt; 0) {
          unsubscribe(subscribeFuture,currentThreadId);
          result.trySuccess(false);
          return;
        }
        tryLockAsync(time,leaseTime,unit,subscribeFuture,result,currentThreadId);
      }
    }
);
    if (!subscribeFuture.isDone()) {
      Timeout scheduledFuture=commandExecutor.getConnectionManager().newTimeout(new TimerTask(){
        @Override public void run(        Timeout timeout) throws Exception {
          if (!subscribeFuture.isDone()) {
            subscribeFuture.cancel(false);
            result.trySuccess(false);
          }
        }
      }
,time.get(),TimeUnit.MILLISECONDS);
      futureRef.set(scheduledFuture);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eL206">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (!future.isSuccess()) {
      log.error(&quot;Can&#x27;t connect to master: {} with slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
      result.setFailure(future.cause());
      return;
    }
    final RedisConnection connection=future.getNow();
    Future&lt;Map&lt;String,String&gt;&gt; clusterFuture=connection.async(RedisCommands.CLUSTER_INFO);
    clusterFuture.addListener(new FutureListener&lt;Map&lt;String,String&gt;&gt;(){
      @Override public void operationComplete(      Future&lt;Map&lt;String,String&gt;&gt; future) throws Exception {
        if (!future.isSuccess()) {
          log.error(&quot;Can&#x27;t execute CLUSTER_INFO for &quot; + connection.getRedisClient().getAddr(),future.cause());
          result.setFailure(future.cause());
          return;
        }
        Map&lt;String,String&gt; params=future.getNow();
        if (&quot;fail&quot;.equals(params.get(&quot;cluster_state&quot;))) {
          RedisException e=new RedisException(&quot;Failed to add master: &quot; + partition.getMasterAddress() + &quot; for slot ranges: &quot;+ partition.getSlotRanges()+ &quot;. Reason - cluster_state:fail&quot;);
          log.error(&quot;cluster_state:fail for &quot; + connection.getRedisClient().getAddr());
          result.setFailure(e);
          return;
        }
        MasterSlaveServersConfig config=create(cfg);
        config.setMasterAddress(partition.getMasterAddress());
        final MasterSlaveEntry e;
        List&lt;Future&lt;Void&gt;&gt; futures=new ArrayList&lt;Future&lt;Void&gt;&gt;();
        if (config.getReadMode() == ReadMode.MASTER) {
          e=new SingleEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
        }
 else {
          config.setSlaveAddresses(partition.getSlaveAddresses());
          e=new MasterSlaveEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
          List&lt;Future&lt;Void&gt;&gt; fs=e.initSlaveBalancer(partition.getFailedSlaveAddresses());
          futures.addAll(fs);
          if (!partition.getSlaveAddresses().isEmpty()) {
            log.info(&quot;slaves: {} added for slot ranges: {}&quot;,partition.getSlaveAddresses(),partition.getSlotRanges());
            if (!partition.getFailedSlaveAddresses().isEmpty()) {
              log.warn(&quot;slaves: {} is down for slot ranges: {}&quot;,partition.getFailedSlaveAddresses(),partition.getSlotRanges());
            }
          }
        }
        Future&lt;Void&gt; f=e.setupMasterEntry(config.getMasterAddress().getHost(),config.getMasterAddress().getPort());
        final Promise&lt;Void&gt; initFuture=newPromise();
        futures.add(initFuture);
        f.addListener(new FutureListener&lt;Void&gt;(){
          @Override public void operationComplete(          Future&lt;Void&gt; future) throws Exception {
            if (!future.isSuccess()) {
              log.error(&quot;Can&#x27;t add master: {} for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
              initFuture.setFailure(future.cause());
              return;
            }
            for (            Integer slot : partition.getSlots()) {
              addEntry(slot,e);
              lastPartitions.put(slot,partition);
            }
            log.info(&quot;master: {} added for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
            initFuture.setSuccess(null);
          }
        }
);
        result.setSuccess(futures);
      }
    }
);
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-5afb94e9df715d6d4206131aee0a7a7eR207">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (!future.isSuccess()) {
      log.error(&quot;Can&#x27;t connect to master: {} with slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
      result.setFailure(future.cause());
      return;
    }
    final RedisConnection connection=future.getNow();
    RFuture&lt;Map&lt;String,String&gt;&gt; clusterFuture=connection.async(RedisCommands.CLUSTER_INFO);
    clusterFuture.addListener(new FutureListener&lt;Map&lt;String,String&gt;&gt;(){
      @Override public void operationComplete(      Future&lt;Map&lt;String,String&gt;&gt; future) throws Exception {
        if (!future.isSuccess()) {
          log.error(&quot;Can&#x27;t execute CLUSTER_INFO for &quot; + connection.getRedisClient().getAddr(),future.cause());
          result.setFailure(future.cause());
          return;
        }
        Map&lt;String,String&gt; params=future.getNow();
        if (&quot;fail&quot;.equals(params.get(&quot;cluster_state&quot;))) {
          RedisException e=new RedisException(&quot;Failed to add master: &quot; + partition.getMasterAddress() + &quot; for slot ranges: &quot;+ partition.getSlotRanges()+ &quot;. Reason - cluster_state:fail&quot;);
          log.error(&quot;cluster_state:fail for &quot; + connection.getRedisClient().getAddr());
          result.setFailure(e);
          return;
        }
        MasterSlaveServersConfig config=create(cfg);
        config.setMasterAddress(partition.getMasterAddress());
        final MasterSlaveEntry e;
        List&lt;RFuture&lt;Void&gt;&gt; futures=new ArrayList&lt;RFuture&lt;Void&gt;&gt;();
        if (config.getReadMode() == ReadMode.MASTER) {
          e=new SingleEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
        }
 else {
          config.setSlaveAddresses(partition.getSlaveAddresses());
          e=new MasterSlaveEntry(partition.getSlotRanges(),ClusterConnectionManager.this,config);
          List&lt;RFuture&lt;Void&gt;&gt; fs=e.initSlaveBalancer(partition.getFailedSlaveAddresses());
          futures.addAll(fs);
          if (!partition.getSlaveAddresses().isEmpty()) {
            log.info(&quot;slaves: {} added for slot ranges: {}&quot;,partition.getSlaveAddresses(),partition.getSlotRanges());
            if (!partition.getFailedSlaveAddresses().isEmpty()) {
              log.warn(&quot;slaves: {} is down for slot ranges: {}&quot;,partition.getFailedSlaveAddresses(),partition.getSlotRanges());
            }
          }
        }
        RFuture&lt;Void&gt; f=e.setupMasterEntry(config.getMasterAddress().getHost(),config.getMasterAddress().getPort());
        final RPromise&lt;Void&gt; initFuture=newPromise();
        futures.add(initFuture);
        f.addListener(new FutureListener&lt;Void&gt;(){
          @Override public void operationComplete(          Future&lt;Void&gt; future) throws Exception {
            if (!future.isSuccess()) {
              log.error(&quot;Can&#x27;t add master: {} for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
              initFuture.setFailure(future.cause());
              return;
            }
            for (            Integer slot : partition.getSlots()) {
              addEntry(slot,e);
              lastPartitions.put(slot,partition);
            }
            log.info(&quot;master: {} added for slot ranges: {}&quot;,partition.getMasterAddress(),partition.getSlotRanges());
            initFuture.setSuccess(null);
          }
        }
);
        result.setSuccess(futures);
      }
    }
);
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35L254">{
  @Override public void operationComplete(  Future&lt;Boolean&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.tryFailure(future.cause());
      return;
    }
    if (optionsCopy.isAckExpected()) {
      final RBlockingQueue&lt;RemoteServiceAck&gt; responseQueue=redisson.getBlockingQueue(responseName,getCodec());
      Future&lt;RemoteServiceAck&gt; ackFuture=responseQueue.pollAsync(optionsCopy.getAckTimeoutInMillis(),TimeUnit.MILLISECONDS);
      ackFuture.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
        @Override public void operationComplete(        Future&lt;RemoteServiceAck&gt; future) throws Exception {
          if (!future.isSuccess()) {
            result.tryFailure(future.cause());
            return;
          }
          RemoteServiceAck ack=future.getNow();
          if (ack == null) {
            Future&lt;RemoteServiceAck&gt; ackFutureAttempt=tryPollAckAgainAsync(optionsCopy,responseQueue,ackName);
            ackFutureAttempt.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
              @Override public void operationComplete(              Future&lt;RemoteServiceAck&gt; future) throws Exception {
                if (!future.isSuccess()) {
                  result.tryFailure(future.cause());
                  return;
                }
                if (future.getNow() == null) {
                  Exception ex=new RemoteServiceAckTimeoutException(&quot;No ACK response after &quot; + optionsCopy.getAckTimeoutInMillis() + &quot;ms for request: &quot;+ request);
                  result.tryFailure(ex);
                  return;
                }
                awaitResultAsync(optionsCopy,result,request,responseName,ackName);
              }
            }
);
          }
 else {
            awaitResultAsync(optionsCopy,result,request,responseName);
          }
        }
      }
);
    }
 else {
      awaitResultAsync(optionsCopy,result,request,responseName);
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-c9a6376afceeb04e75da83fe62c76a35R254">{
  @Override public void operationComplete(  Future&lt;Boolean&gt; future) throws Exception {
    if (!future.isSuccess()) {
      result.tryFailure(future.cause());
      return;
    }
    if (optionsCopy.isAckExpected()) {
      final RBlockingQueue&lt;RemoteServiceAck&gt; responseQueue=redisson.getBlockingQueue(responseName,getCodec());
      RFuture&lt;RemoteServiceAck&gt; ackFuture=responseQueue.pollAsync(optionsCopy.getAckTimeoutInMillis(),TimeUnit.MILLISECONDS);
      ackFuture.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
        @Override public void operationComplete(        Future&lt;RemoteServiceAck&gt; future) throws Exception {
          if (!future.isSuccess()) {
            result.tryFailure(future.cause());
            return;
          }
          RemoteServiceAck ack=future.getNow();
          if (ack == null) {
            RFuture&lt;RemoteServiceAck&gt; ackFutureAttempt=tryPollAckAgainAsync(optionsCopy,responseQueue,ackName);
            ackFutureAttempt.addListener(new FutureListener&lt;RemoteServiceAck&gt;(){
              @Override public void operationComplete(              Future&lt;RemoteServiceAck&gt; future) throws Exception {
                if (!future.isSuccess()) {
                  result.tryFailure(future.cause());
                  return;
                }
                if (future.getNow() == null) {
                  Exception ex=new RemoteServiceAckTimeoutException(&quot;No ACK response after &quot; + optionsCopy.getAckTimeoutInMillis() + &quot;ms for request: &quot;+ request);
                  result.tryFailure(ex);
                  return;
                }
                awaitResultAsync(optionsCopy,result,request,responseName,ackName);
              }
            }
);
          }
 else {
            awaitResultAsync(optionsCopy,result,request,responseName);
          }
        }
      }
);
    }
 else {
      awaitResultAsync(optionsCopy,result,request,responseName);
    }
  }
}
</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-129a09b1d29d027839d013b36ef59195L72">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (future.isSuccess()) {
      final RedisConnection c=future.getNow();
      Promise&lt;RedisConnection&gt; connectionFuture=connectionManager.newPromise();
      connectionManager.getConnectListener().onConnect(connectionFuture,c,null,connectionManager.getConfig());
      connectionFuture.addListener(new FutureListener&lt;RedisConnection&gt;(){
        @Override public void operationComplete(        Future&lt;RedisConnection&gt; future) throws Exception {
          Future&lt;String&gt; r=c.async(connectionManager.getConfig().getPingTimeout(),RedisCommands.PING);
          result.put(c,r);
          latch.countDown();
        }
      }
);
    }
 else {
      latch.countDown();
    }
  }
}
</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-129a09b1d29d027839d013b36ef59195R73">{
  @Override public void operationComplete(  Future&lt;RedisConnection&gt; future) throws Exception {
    if (future.isSuccess()) {
      final RedisConnection c=future.getNow();
      RPromise&lt;RedisConnection&gt; connectionFuture=connectionManager.newPromise();
      connectionManager.getConnectListener().onConnect(connectionFuture,c,null,connectionManager.getConfig());
      connectionFuture.addListener(new FutureListener&lt;RedisConnection&gt;(){
        @Override public void operationComplete(        Future&lt;RedisConnection&gt; future) throws Exception {
          RFuture&lt;String&gt; r=c.async(connectionManager.getConfig().getPingTimeout(),RedisCommands.PING);
          result.put(c,r);
          latch.countDown();
        }
      }
);
    }
 else {
      latch.countDown();
    }
  }
}
</a>
                                </li>
                                
                            </ul>
                            
                            <li><a href="#" onclick="toggle_visibility('VarRename');"><i class="fa fa-plus"
                                                                                                aria-hidden="true">
                                VarRename</i></a></li>
                            <ul id="VarRename" , style="display: none;">
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L271">future</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R270">subscribeFuture</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L307">future</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R306">subscribeFuture</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L270">future</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R269">subscribeFuture</a>
                                </li>
                                
                                <li><a href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468L269">future</a> to <a
                                        href="https://github.com/redisson/redisson/commit/d00a1a7ae853dada9c4a5d165e38c63780020819?diff=split#diff-522d7dfc8d1c00f055ada8e699e7a468R268">subscribeFuture</a>
                                </li>
                                
                            </ul>
                            
                        </ol>

                        <ul>
                            
                        </ul>
                    </div>
                </div>
            </div>

            <!-- initialize jQuery Library -->
            <script type="text/javascript" src="../../js/jquery.js"></script>
            <!-- Bootstrap jQuery -->
            <script type="text/javascript" src="../../js/bootstrap.min.js"></script>
            <!-- Style Switcher -->
            <script type="text/javascript" src="../../js/style-switcher.js"></script>
            <!-- Owl Carousel -->
            <script type="text/javascript" src="../../js/owl.carousel.js"></script>
            <!-- PrettyPhoto -->
            <script type="text/javascript" src="../../js/jquery.prettyPhoto.js"></script>
            <!-- Bxslider -->
            <script type="text/javascript" src="../../js/jquery.flexslider.js"></script>
            <!-- CD Hero slider -->
            <script type="text/javascript" src="../../js/cd-hero.js"></script>
            <!-- Isotope -->
            <script type="text/javascript" src="../../js/isotope.js"></script>
            <script type="text/javascript" src="../../js/ini.isotope.js"></script>
            <!-- Wow Animation -->
            <script type="text/javascript" src="../../js/wow.min.js"></script>
            <!-- SmoothScroll -->
            <script type="text/javascript" src="../../js/smoothscroll.js"></script>
            <!-- Eeasing -->
            <script type="text/javascript" src="../../js/jquery.easing.1.3.js"></script>
            <!-- Counter -->
            <script type="text/javascript" src="../../js/jquery.counterup.min.js"></script>
            <!-- Waypoints -->
            <script type="text/javascript" src="../../js/waypoints.min.js"></script>
            <!-- Template custom -->
            <script type="text/javascript" src="../../js/custom.js"></script>
        </div>
    </section>
</div>
</body>

<script type="text/javascript">
    <!--
    function toggle_visibility(id) {
        var e = document.getElementById(id);
        if (e.style.display == 'block')
            e.style.display = 'none';
        else
            e.style.display = 'block';
    }

    //-->
</script>
</html>
